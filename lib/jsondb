#!/usr/bin/env node

var async = require('async'),
	fs = require('fs'),
	events = require('events'),
	util = require('util'),
	flags = {
		CONNECTING: null,
		DELETING_DB: null
	}

/**
 * database class
 */
var DB = function jsondb(){

	events.EventEmitter.call(this)
	var self = this

	//@public
	this.dbname = null
	this.database = null
	this.storage = '.'
	this.handle = null

	//@public close connection
	this.close = function(fn){

		this.dbname = null
		this.database = null
		this.storage = '.'
		this.handle = null
		if(fn)
			fn()
		return this
	}

	//@public connect to database
	this.connect = function(dbname, fn){

		flags.CONNECTING = true
		self.dbname = dbname
		self.database = getDBLocation(this.dbname)
		var _db = self.database
		var _dbname = dbname

		//check database file
		var exists = fs.existsSync(_db)

		if(!exists){
						
			var json = {
				dbname: _dbname,
				tables: {}
			}
			var str = JSON.stringify(json, null, 4)
			fs.writeFileSync(_db, str)

		}
		if(fn){
			fn()
		}
		return this
	}

	//@public create a table
	this.create = function(what, tblname, fn){

		var j = require(self.database)

		switch(what){

			case 'field':

				var fields = j.tables[tblname.table].fields

				//if field exists return
				if(~fields.indexOf(tblname.field))
					return this
				else{

					//if fields is empty
					if(fields.length==0){
						if(typeof(tblname.field)=='string')
							fields = [tblname.field]
						else
							fields = tblname.field
					}
					else
						fields = fields.concat(tblname.field)
				}
				j.tables[tblname.table].fields = fields
				break;

			case 'table':
				j.tables[tblname] = {fields: [], data: []}
				break;
		}

		this.setJSON(j, fn)
		return this
	}

	this.delete_db = function(dbname, fn){

		var cb = fn,
			self = this
			_db = getDBLocation(dbname)

		flags.DELETING_DB = true

		//setup database filename
		this.database = _db

		fs.exists(this.database, function(exists){

			var _self = self
				_cb = cb
				_dbname = dbname

			if(exists){
				fs.unlink(_db, function(err){
					if(err)
						throw new Error(err)

					if(_self.dbname==_dbname)
						_self.close()

					if(_cb)
						_cb()
				})
			}
			else
				if(_cb)
					_cb()
		})
	}

	this.delete_field = function(tblname, field, fn){

		var j = require(self.database)
		var index = j.tables[tblname].fields.indexOf(field)

		j.tables[tblname].fields.splice(index, 1)
		this.setJSON(j, fn)

		return this
	}

	this.delete_row = function(tblname, data, fn){

		var j = require(self.database)
		var rows = j.tables[tblname].data
		var col = j.tables[tblname].fields.indexOf(data[0])

		rows.forEach(function(row, index){
			if(row[col]==data[1])
				rows.splice(index, 1)
		})

		j.tables[tblname].data = rows

		self.setJSON(j, fn)
	}

	this.delete_table = function(tblname, fn){

		var j = require(self.database)
		delete j.tables[tblname]
		this.setJSON(j, fn)
	}

	this.insert = function(tblname, row, fn){

		var j = require(self.database)

		//check num of cols matches
		if( row.length!=j.tables[tblname].fields.length )
			throw new Error('Invalid number of cols')

		j.tables[tblname].data.push(row)
		this.setJSON(j, fn)

		return this
	}

	this.setStorage = function(path, fn){

		self.storage = path

		if(fn)
			fn()
		return this
	}

	this.update_row = function(tblname, data, fn){

		var j = require(self.database),
			table = j.tables[tblname],
			fields = j.tables[tblname].fields,
			rows = j.tables[tblname].data,
			col_where = fields.indexOf(data.where[0]),
			col_set = fields.indexOf(data.set[0])

		rows.forEach(function(row, index){
			if(row[col_where]==data.where[1])
				rows[index][col_set]=data.set[1]
		})

		j.tables[tblname].data = rows

		self.setJSON(j, fn)
	}

	/**
	 * Handles all queries, does check for connection etc.
	 * @deprecated not in use in this version
	 */
	this.query = function(method){

		var _self = this
		var _method = method
		var _args = arguments

		//callback to see if db exists
		function queryCheck(ok){
			_self[method]( _args )
		}

		//check if connected
		if( method!="connect" )
			this.connected(queryCheck)
		queryCheck()
	}

	/**
	 * Check if connected, called by this.query
	 * @deprecated not in use in this version
	 * @private
	 */
	function connected(fn){
		var ok = true
		fn(ok)
	}

	/**
	 * Get the full path to the a database. Uses current storage
	 * @private
	 * @param  {string} dbname Required. Database name
	 * @return {string}        
	 */
	function getDBLocation(dbname){

		return process.cwd()+'/'+db.storage+'/'+dbname+'.json'
	}

	this.setJSON = function(json, fn){
		
		var _json = JSON.stringify(json, null, 4)
		fs.writeFile(db.database, _json, {flag: 'w'}, fn)
		return
	}

}
util.inherits(DB, events.EventEmitter)
var db = new DB()
var queue = []

/**
 * driver
 */
var driver = {

	close: function(fn){
		db.close(fn)
		//queue.push(db.close.bind(db, fn))
		return this
	},

	connect: function(dbname, fn){
		db.connect(dbname, fn)
		//queue.push(db.connect.bind(db, dbname, fn))
		return this
	},

	create: function(what, tblname, fn){

		db.create(what, tblname, fn)
		return this
	},

	delete: function(what, val, fn){

		switch(what){

			case 'database':
				db.delete_db(val, fn)
				break;

			case 'field':
				db.delete_field(val.table, val.field, fn)
				break;

			case 'row':
				db.delete_row(val.table, val.col, fn)
				break;

			case 'table':
				db.delete_table(val, fn)
				break;

		}
	},
	
	getDB: function(){
		
		return db
	},

	insert: function(tblname, row, fn){

		db.insert(tblname, row, fn)
		return this
	},

	update: function(what, data, fn){
		
		switch(what){

			case 'row':
				db.update_row(data.table, data.data, fn)
				break;
		}
		return this
	},

	run: function(){
		
	    async.series(queue, function(err, results){
	    	if(err)
	    		throw new Error(err)
	    })

		return null
	},

	setStorage: function(path, fn){
		db.setStorage(path, fn)
		//queue.push(db.setStorage.bind(db, path, fn))
		return this
	}
}

module.exports = driver
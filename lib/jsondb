#!/usr/bin/env node

var async = require('async'),
	fs = require('fs'),
	events = require('events'),
	util = require('util'),
	flags = {
		CONNECTING: null,
		DELETING_DB: null
	}

/**
 * database class
 */
var DB = function jsondb(){

	events.EventEmitter.call(this)
	var self = this

	//@public
	this.dbname = null
	this.database = null
	this.storage = '.'
	this.handle = null

	/**
	 * Reset class parameters
	 * @param  {Function} fn Callback
	 */
	this.close = function(fn){

		this.dbname = null
		this.database = null
		this.storage = '.'
		this.handle = null
		if(fn)
			fn()
		return this
	}

	/**
	 * Connect or create a database
	 * @param  {string}   dbname The database name
	 * @param  {Function} fn     Callback
	 */
	this.connect = function(dbname, fn){

		flags.CONNECTING = true
		self.dbname = dbname
		self.database = getDBLocation(this.dbname)

		//check database file
		var exists = fs.existsSync(self.database),
			json

		if(!exists){
						
			json = {
				dbname: dbname,
				tables: {}
			}
			var str = JSON.stringify(json, null, 4)
			fs.writeFileSync(self.database, str)

		}else
			json = require(self.database)
		
		if(fn)
			fn(json)

		return this
	}

	//@public create a table
	this.create = function(what, tblname, fn){


		switch(what){

			case 'col':

				var col = j.tables[tblname.table].cols

				//if field exists return
				if(~fields.indexOf(tblname.field))
					return this
				else{

					//if fields is empty
					if(fields.length==0){
						if(typeof(tblname.field)=='string')
							fields = [tblname.field]
						else
							fields = tblname.field
					}
					else
						fields = fields.concat(tblname.field)
				}
				j.tables[tblname.table].fields = fields
				break;

			case 'table':
				break;

			default:
				self.error('Unkown action: '+what)
				break;
		}

		this.setJSON(j, fn)
		return this
	}

	/**
	 * Create a table
	 * @param  {string}   tblname The table name
	 * @param  {Function} fn      Callback
	 */
	this.create_table = function(tblname, fn){

		var j = require(self.database)
		j.tables[tblname] = {cols: [], data: []}

		this.setJSON(j, fn)
		return this
	}

	/**
	 * Delete a database
	 * @param  {string}   dbname The database name
	 * @param  {Function} fn     Callback
	 */
	this.delete_db = function(dbname, fn){

		var cb = fn,
			self = this
			_db = getDBLocation(dbname)

		flags.DELETING_DB = true

		//setup database filename
		this.database = _db

		fs.exists(this.database, function(exists){

			var _self = self
				_cb = cb
				_dbname = dbname

			if(exists){
				fs.unlink(_db, function(err){
					if(err)
						throw new Error(err)

					if(_self.dbname==_dbname)
						_self.close()

					if(_cb)
						_cb()
				})
			}
			else
				if(_cb)
					_cb()
		})
	}

	this.delete_field = function(tblname, field, fn){

		var j = require(self.database)
		var index = j.tables[tblname].fields.indexOf(field)

		j.tables[tblname].fields.splice(index, 1)
		this.setJSON(j, fn)

		return this
	}

	this.delete_row = function(tblname, data, fn){

		var j = require(self.database)
		var rows = j.tables[tblname].data
		var col = j.tables[tblname].fields.indexOf(data[0])

		rows.forEach(function(row, index){
			if(row[col]==data[1])
				rows.splice(index, 1)
		})

		j.tables[tblname].data = rows

		self.setJSON(j, fn)
	}

	this.delete_table = function(tblname, fn){

		var j = require(self.database)
		delete j.tables[tblname]
		this.setJSON(j, fn)
	}

	this.error = function(msg){

		throw new Error(msg)
	}

	this.insert = function(tblname, row, fn){

		var j = require(self.database)

		//check num of cols matches
		if( row.length!=j.tables[tblname].fields.length )
			this.error('Invalid number of cols')

		j.tables[tblname].data.push(row)
		this.setJSON(j, fn)

		return this
	}

	/**
	 * Set database path
	 * @param {string}   path The path to store database in
	 * @param {Function} fn   Callback
	 */
	this.setStorage = function(path, fn){

		self.storage = path

		if(fn)
			fn()
		return this
	}

	this.update_col = function(tblname, data, fn){

		var j = require(self.database)
	}

	this.update_row = function(tblname, data, fn){

		var j = require(self.database),
			table = j.tables[tblname],
			fields = j.tables[tblname].fields,
			rows = j.tables[tblname].data,
			col_where = fields.indexOf(data.where[0]),
			col_set = fields.indexOf(data.set[0])

		rows.forEach(function(row, index){
			if(row[col_where]==data.where[1])
				rows[index][col_set]=data.set[1]
		})

		j.tables[tblname].data = rows

		self.setJSON(j, fn)
	}

	/**
	 * Rename a table
	 * @param  {json}   data @see _driver:update()
	 * @param  {Function} fn   Callback
	 */
	this.update_table = function(data, fn){

		var j = require(self.database)

		//validate table name
		var regex = /^[a-zA-Z][a-zA-Z0-9_]+$/i
		if(!data.set[1].match(regex))
			this.error('Only alphanumeric and underscore allowed for table names')

		//create new key
		j.tables[data.set[1]] = j.tables[data.set[0]]

		//delete old key
		delete j.tables[data.set[0]]
		this.setJSON(j, fn)
		return this
	}

	/**
	 * Handles all queries, does check for connection etc.
	 * @deprecated not in use in this version
	 */
	this.query = function(tblname, query, fn){

		var j = require(self.database),
			table = j.tables[tblname],
			cols = table.fields,
			data = table.data,
			res = [],
			queries = []

		//cast query to array (in single object passed as query arg)
		Array.isArray(query) ?
			queries = query :
			queries = [query] 


		queries.forEach(function(test, index){
			data.forEach(function(row, i){

				col = cols.indexOf(test.where[0])

				if(col<0)
					self.error('Unkown col: '+test.where[0])

				if(row[col]==test.where[1]){
					r = {}
					cols.forEach(function(c, x){
						r[c] = row[x]
					})
					res.push(r)
				}
			})
		})

		fn(res)
	}

	/**
	 * Get the full path to the a database. Uses current storage
	 * @private
	 * @param  {string} dbname Required. Database name
	 * @return {string}        
	 */
	function getDBLocation(dbname){

		return process.cwd()+'/'+db.storage+'/'+dbname+'.json'
	}

	this.setJSON = function(json, fn){
		
		var _json = JSON.stringify(json, null, 4)
		fs.writeFile(db.database, _json, {flag: 'w'}, fn)
		return
	}

}
util.inherits(DB, events.EventEmitter)
var db = new DB()
var queue = []

/**
 * driver
 */
var driver = {

	/**
	 * Close a connection.
	 * Resets class params
	 * @param  {Function} fn Callback
	 * @return {this}
	 */
	close: function(fn){
		db.close(fn)
		//queue.push(db.close.bind(db, fn))
		return this
	},

	/**
	 * Connect to a database.
	 * Will create database if none exists. Use this.setStorage() to set the
	 * database file path
	 * @param  {string}   dbname The database name
	 * @param  {Function} fn     Callback
	 * @return this
	 */
	connect: function(dbname, fn){
		db.connect(dbname, fn)
		//queue.push(db.connect.bind(db, dbname, fn))
		return this
	},

	/**
	 * Create query.
	 * TO create a table:
	 *  - db.create('table', 'my_table_name', fn)
	 * @param  {enum}   what What to create. Possible values are: table
	 * @param  {mixed}   data Parameters to pass for create. See method
	 * description
	 * @param  {Function} fn   Callback
	 * @return {this}        Returns self for chaining
	 */
	create: function(what, data, fn){

		switch(what){

			case 'table':
				db.create_table(data, fn)
				break;
		}

		return this
	},

	/**
	 * Delete query.
	 * To delete a database:
	 *  - db.delete('database','database_name', fn)
	 * @param  {enum}   what What to delete. Possible values are: database,
	 * field, row, table
	 * @param  {mixed}   val  Parameters to pass for delete. See method
	 * description
	 * @param  {Function} fn   Callback
	 * @return {this}        Returns self for chaining
	 */
	delete: function(what, val, fn){

		switch(what){

			case 'database':
				db.delete_db(val, fn)
				break;

			case 'field':
				db.delete_field(val.table, val.field, fn)
				break;

			case 'row':
				db.delete_row(val.table, val.col, fn)
				break;

			case 'table':
				db.delete_table(val, fn)
				break;

		}

		return this
	},
	
	getDB: function(){
		
		return db
	},

	insert: function(tblname, row, fn){

		db.insert(tblname, row, fn)
		return this
	},

	/**
	 * Update query.
	 * To update a table name:
	 *  - db.update('table', {set: ["old_name","new_name"]}, fn)
	 * @param  {enum}   what What to update. Possible values are: table, col,
	 * row
	 * @param  {mixed}   data Parameters to pass for update. See method
	 * description
	 * @param  {Function} fn   Callback
	 * @return {this}        Returns self for chaining
	 */
	update: function(what, data, fn){
		
		switch(what){

			case 'col':
				db.update_col(data.table, data.data, fn)
				break;

			case 'row':
				db.update_row(data.table, data.data, fn)
				break;

			case 'table':
				db.update_table(data, fn)
		}
		return this
	},

	query: function(tblname, query, fn){

		db.query(tblname, query, fn)
		return this
	},

	run: function(){
		
	    async.series(queue, function(err, results){
	    	if(err)
	    		throw new Error(err)
	    })

		return null
	},

	/**
	 * Set the database path.
	 * Sets the path the database json file will be stored in
	 * @param {string}   path The full path to the database directory
	 * @param {Function} fn   Callback
	 * @return {this} Returns self for chaining
	 */
	setStorage: function(path, fn){
		db.setStorage(path, fn)
		//queue.push(db.setStorage.bind(db, path, fn))
		return this
	}
}

module.exports = driver